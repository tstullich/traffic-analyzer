package org.sjunion.trafficanalyzer;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.regex.Matcher;
import java.util.regex.Pattern;

/**
 * A small class that implements a Binary Search Tree
 * in order to sort a list of traffic packets from a
 * CSV generated by WireShark and perform certain 
 * operations on the resulting data. Lots of recursion
 * is used, so I cannot guarantee that Stack Overflows
 * won't occur if the data set being processed is too 
 * big for the stack to handle.
 * @author cstech
 *
 */
public class TrafficTree {
	private TreeNode root;
	private int size;
	private static Pattern pattern;
	private static Matcher matcher;
	
	private static final String IPADDRESS_PATTERN = 
			"^([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\." +
			"([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\." +
			"([01]?\\d\\d?|2[0-4]\\d|25[0-5])\\." +
			"([01]?\\d\\d?|2[0-4]\\d|25[0-5])$";
	
	public TrafficTree() {
		root = null;
		size = 0;
		pattern = Pattern.compile(IPADDRESS_PATTERN);
	}
	
	/**
	 * The recursive helper method in order to insert
	 * a new node into the tree
	 * @param node the current node being visited
	 * @param insertNode the node to be inserted
	 */
	private void addNodeRec(TreeNode node, TreeNode insertNode) {
		if (node.compareTo(insertNode.address) == 0) {
			node.addTraffic(insertNode.traffic.remove(0));
			return;
		}
		//Go left on comparison
		else if (node.compareTo(insertNode.address) > 0) {
			if (node.left == null) {
				node.left = insertNode;
				size++;
				return;
			}
			else {
				addNodeRec(node.left, insertNode);
			}
		}
		//Go right automatically
		else {
			if (node.right == null) {
				node.right = insertNode;
				size++;
				return;
			}
			else {
				addNodeRec(node.right, insertNode);
			}
		}
	}
	
	/**
	 * Allows the user to add a new node to the tree
	 * @param data the string of data to be processed
	 */
	public void addNode(String data) {
		TreeNode newNode = new TreeNode(data);
		if (newNode.address == null) {
			return;
		}
		else if (root == null) {
			root = newNode;
			size++;
		} 
		else {
			addNodeRec(root, newNode);
		}
	}
	
	/**
	 * Recursively prints the addresses in the 
	 * tree starting at the root
	 * @param root the root of the tree
	 */
	private void printIPs(TreeNode root) {
		if (root == null) {
			return;
		}
		System.out.println(root.address);
		printIPs(root.left);
		printIPs(root.right);
	}
	
	/**
	 * Allows the user to print out the given nodes
	 * in the tree.
	 */
	public void printIPs() {
		printIPs(this.root);
	}
	
	/**
	 * Performs a search on the tree data structure recursively and
	 * returns a value based on its success.
	 * @param node the node to search for
	 * @param address the address to match when searching (key)
	 * @return <b>TreeNode</b> if the node was found <br></br>
	 * 		   <b>null</b> if the node does not exist in the tree
	 */
	public TreeNode searchTreeRec(TreeNode node, String address) {
		if (node == null || node.address.equals(address)) {
			return node;
		}
		else if (node.address.compareTo(address) < 0) {
			searchTreeRec(node.left, address);
		}
		else {
			searchTreeRec(node.right, address);
		}
		return node;
	}
	
	/**
	 * Searches the tree for the given node that contains the address
	 * @param address the address to look for
	 * @return <b>TreeNode</b> if it exists in the tree <br></br>
	 * 		   <b>null</b> if the node is not in the tree
	 */
	public TreeNode searchTree(String address) {
		return searchTreeRec(root, address);
	}
	
	/**
	 * Recursively searches through the tree and packets to find
	 * nodes that try to use a certain protocol
	 * @param root the node to start on
	 * @param list the list to store the nodes
	 * @param address the protocol to be found
	 */
	private void findProtocolsHelper(TreeNode root, ArrayList<TreeNode> list, String protocol) {
		if (root == null){
			return;
		}
		for (String[] packet : root.getTraffic()) {
			if (packet[4].equalsIgnoreCase(protocol) && !list.contains(root)) {
				list.add(root);
			}
		}
		findProtocolsHelper(root.left, list, protocol);
		findProtocolsHelper(root.right, list, protocol);
	}
	
	/**
	 * Finds a list of IP addresses that try to access
	 * a certain protocol.
	 * @param the protocol to look for
	 * @return a list of all IP addresses using the protocol
	 */
	public ArrayList<TreeNode> findProtocol(String protocol) {
		ArrayList<TreeNode> list = new ArrayList<TreeNode>();
		findProtocolsHelper(root, list, protocol);
		return list;
	}
	
	/**
	 * Recursive method to find IP addresses that access dead resources
	 * @param root the node to start on
	 * @param list the list to store found nodes in
	 * @param address the address to look for
	 */
	private void findOrphansHelper(TreeNode root, HashMap<TreeNode, ArrayList<String>> list, String address) {
		if (root == null){
			return;
		}
		for (String[] packet : root.getTraffic()) {
			if (packet[3].equalsIgnoreCase(address) && list.containsKey(root)) {
				String s = "Port: " + packet[7] + " Packet: " + packet[4];
				list.get(root).add(s);
			}
			else if (packet[3].equalsIgnoreCase(address) && !list.containsKey(root)) {
				String s = "Port: " + packet[7] + " Packet: " + packet[4];
				ArrayList<String> newList = new ArrayList<String>();
				newList.add(s);
				list.put(root, newList);
			}
		}
		findOrphansHelper(root.left, list, address);
		findOrphansHelper(root.right, list, address);
	}
	
	/**
	 * Finds IP addresses that try to access dead resources
	 * @param address the address to that is no longer in use
	 * @return ip addresses that point to address
	 */
	public HashMap<TreeNode, ArrayList<String>> findOrphans(String address) {
		HashMap<TreeNode, ArrayList<String>> orphans = new HashMap<TreeNode, ArrayList<String>>();
		findOrphansHelper(root, orphans, address);
		return orphans;
	}
	
	/**
	 * Returns the size of the current tree. Value can be 0
	 * @return the size of the tree
	 */
	public int size() {
		return this.size;
	}
	
	/**
	 * Quick convenience method to see if a given string has
	 * the valid IPv4 format. (i.e. 192.168.0.1) 
	 * <br><i>Some exceptions may apply</i></br>
	 * @param ip the string to check
	 * @return <b>true</b> if the string has the right format <br></br>
	 * 		   <b>false</b> if the string does not have the right format
	 */
	public static boolean isValidIP(String ip) {
		matcher = pattern.matcher(ip);
		return matcher.matches();
	}
	
	/**
	 * Quick inner class that will represent a node in the
	 * binary tree. <b>Things to fix</b>: <dl>
	 *  <li>Create actual wrapper class for packet data. Current implementation
	 *   leaves it too easy to edit for outer classes.</li> </dl>
	 * @author cstech
	 *
	 */
	class TreeNode implements Comparable<String>{
		private String address;
		private TreeNode right;
		private TreeNode left;
		private ArrayList<String[]> traffic;
		
		//Data is going to be split on creation
		public TreeNode(String data) {
			right = null;
			left = null;
			traffic = new ArrayList<String[]>();
			String[] newData = data.split(",");
			
			//Clean the String of useless characters
			for (int i = 0; i < newData.length; i++) {
				newData[i] = newData[i].replace("\"", "");
			}
			traffic.add(newData);
			if (isValidIP(newData[2])) {
				address = newData[2];
			}
			else {
				address = null;
			}
		}
		
		/**
		 * Takes key data points from the list of traffic
		 * and turns them into a formatted string.
		 * @return the formatted String
		 */
		public String toString() {
			StringBuilder str = new StringBuilder();
			for (String[] packet : traffic) {
				str.append("Packet: " + packet[0] + " ");
				str.append("Source: " + packet[2] + " -> " + packet[3] + "\n");
			}
			return str.toString();
		}
		
		/**
		 * Returns all the currently recorded traffic from the node
		 * @return the list of traffic
		 */
		public ArrayList<String[]> getTraffic() {
			return this.traffic;
		}
		
		/**
		 * Returns the IP address of the given node
		 * @return the IP address 
		 */
		public String getAddress() {
			return this.address;
		}
		
		/**
		 * Adds a traffic packet to the node.
		 * @param traffic An array of necessary data
		 */
		public void addTraffic(String[] traffic) {
			this.traffic.add(traffic);
		}

		/**
		 * Compares IP Adresses to see if they match or are greater(non-Javadoc)
		 * @see java.lang.Comparable#compareTo(java.lang.Object)
		 */
		@Override
		public int compareTo(String address2) {			
			
			//Split to compare them
			String[] addr1 = address.split("\\.");
			String[] addr2 = address2.split("\\.");			
			
			int value1 = 0, value2 = 0;
			for (int i = 0; i < addr1.length; i++) {
				value1 += Integer.valueOf(addr1[i]);
				value2 += Integer.valueOf(addr2[i]);
			}
			
			return value1 - value2;
		}
	}
}